#!/bin/bash
set -e

# Function to log to stderr
log() {
    echo "$@" >&2
}

# Check if context parameter is provided
if [ -z "$1" ]; then
    log "Error: Missing context parameter"
    log "Usage: ./deployContracts '{\"version\":\"0.0.1\",\"context\":{...}}'"
    exit 1
fi

# Parse the JSON context
CONTEXT="$1"

# Check for required tools
if ! command -v jq &> /dev/null; then
    log "Error: jq is required for JSON parsing. Please install jq first."
    exit 1
fi

if ! command -v yq &> /dev/null; then
    log "Error: yq is required for YAML parsing. Please install yq first."
    exit 1
fi

if ! command -v make &> /dev/null; then
    log "Error: make is required for contract deployment. Please install make first."
    exit 1
fi

# Extract required values from context
ENVIRONMENT=$(echo "$CONTEXT" | jq -r '.context.name')
L1_RPC_URL=$(echo "$CONTEXT" | jq -r '.context.chains.l1.rpc_url')
L2_RPC_URL=$(echo "$CONTEXT" | jq -r '.context.chains.l2.rpc_url')
PRIVATE_KEY_DEPLOYER=$(echo "$CONTEXT" | jq -r '.context.deployer_private_key')
PRIVATE_KEY_AVS=$(echo "$CONTEXT" | jq -r '.context.avs.avs_private_key')
AVS_ADDRESS=$(echo "$CONTEXT" | jq -r '.context.avs.address')
METADATA_URI=$(echo "$CONTEXT" | jq -r '.context.avs.metadata_url')

# Validate required fields exist in JSON
if [ "$L1_RPC_URL" == "null" ] || [ -z "$L1_RPC_URL" ]; then
    log "Error: Missing L1_RPC_URL in context"
    exit 1
fi

if [ "$L2_RPC_URL" == "null" ] || [ -z "$L2_RPC_URL" ]; then
    log "Error: Missing L2_RPC_URL in context"
    exit 1
fi

if [ "$PRIVATE_KEY_DEPLOYER" == "null" ] || [ -z "$PRIVATE_KEY_DEPLOYER" ]; then
    log "Error: Missing deployer_private_key in context"
    exit 1
fi

if [ "$PRIVATE_KEY_AVS" == "null" ] || [ -z "$PRIVATE_KEY_AVS" ]; then
    log "Error: Missing avs.avs_private_key in context"
    exit 1
fi

if [ "$ENVIRONMENT" == "null" ] || [ -z "$ENVIRONMENT" ]; then
    log "Error: Missing name (environment) in context"
    exit 1
fi

if [ "$AVS_ADDRESS" == "null" ] || [ -z "$AVS_ADDRESS" ]; then
    log "Error: Missing avs.address in context"
    exit 1
fi

if [ "$METADATA_URI" == "null" ] || [ -z "$METADATA_URI" ]; then
    log "Error: Missing avs.metadata_url in context"
    exit 1
fi

# Check if the template-specific AVS environment YAML file exists
ENVIRONMENT_YAML_FILE=".hourglass/context/${ENVIRONMENT}.yaml"
if [ ! -f "$ENVIRONMENT_YAML_FILE" ]; then
    log "Error: AVS environment file ${ENVIRONMENT_YAML_FILE} does not exist"
    exit 1
fi

# Read values from the environment YAML file using yq
ALLOCATION_MANAGER_ADDRESS="0x948a420b8CC1d6BFd0B6087C2E7c344a2CD0bc39"  # Example default, could be read from YAML if present

# Read operator sets from the YAML
AGGREGATOR_OPERATOR_SET_ID=$(yq -r '.aggregator.operatorSetId' "$ENVIRONMENT_YAML_FILE")
EXECUTOR_OPERATOR_SET_ID=$(yq -r '.executor.operatorSetId' "$ENVIRONMENT_YAML_FILE")
TASK_SLA=$(yq -r '.mailbox.taskSla' "$ENVIRONMENT_YAML_FILE")

# Validate YAML values
if [ "$AGGREGATOR_OPERATOR_SET_ID" == "null" ]; then
    log "Error: Missing aggregator.operatorSetId in ${ENVIRONMENT_YAML_FILE}"
    exit 1
fi

if [ "$EXECUTOR_OPERATOR_SET_ID" == "null" ]; then
    log "Error: Missing executor.operatorSetId in ${ENVIRONMENT_YAML_FILE}"
    exit 1
fi

if [ "$TASK_SLA" == "null" ]; then
    log "Error: Missing mailbox.taskSla in ${ENVIRONMENT_YAML_FILE}"
    exit 1
fi

# Get strategies for aggregator and executor from YAML
# yq query to extract the strategies array for the given operator set ID
get_strategies_for_set_id() {
    local set_id=$1
    local yaml_file=$2
    
    # Use yq to extract the strategies as a JSON array
    # -o=json ensures output is in JSON format
    yq -o=json ".operatorSets[] | select(.id == $set_id) | .strategies" "$yaml_file"
}

# Extract strategies
AGGREGATOR_STRATEGIES=$(get_strategies_for_set_id "$AGGREGATOR_OPERATOR_SET_ID" "$ENVIRONMENT_YAML_FILE")

if [ "$AGGREGATOR_STRATEGIES" == "null" ] || [ -z "$AGGREGATOR_STRATEGIES" ]; then
    log "Error: Could not extract aggregator strategies for operatorSetId ${AGGREGATOR_OPERATOR_SET_ID} in ${ENVIRONMENT_YAML_FILE}"
    exit 1
fi

EXECUTOR_STRATEGIES=$(get_strategies_for_set_id "$EXECUTOR_OPERATOR_SET_ID" "$ENVIRONMENT_YAML_FILE")

if [ "$EXECUTOR_STRATEGIES" == "null" ] || [ -z "$EXECUTOR_STRATEGIES" ]; then
    log "Error: Could not extract executor strategies for operatorSetId ${EXECUTOR_OPERATOR_SET_ID} in ${ENVIRONMENT_YAML_FILE}"
    exit 1
fi

# Validate Ethereum addresses (basic check)
validate_eth_address() {
    local addr=$1
    local name=$2
    if [[ ! "$addr" =~ ^0x[a-fA-F0-9]{40}$ ]]; then
        log "Error: $name must be a valid Ethereum address (0x followed by 40 hex characters)"
        exit 1
    fi
}

validate_eth_address "$AVS_ADDRESS" "AVS_ADDRESS"
validate_eth_address "$ALLOCATION_MANAGER_ADDRESS" "ALLOCATION_MANAGER_ADDRESS"

log "Starting contract deployment using context for environment: $ENVIRONMENT"

# Change to contracts directory
cd contracts

# Step 1: Deploy TaskMailbox contract (only for devnet environment)
if [ "$ENVIRONMENT" == "devnet" ]; then
    log "1. Deploying TaskMailbox contract (devnet only)..."
    PRIVATE_KEY_DEPLOYER="${PRIVATE_KEY_DEPLOYER}" make deploy-task-mailbox RPC_URL="${L2_RPC_URL}" ENVIRONMENT="${ENVIRONMENT}" >&2
else
    log "Skipping TaskMailbox deployment for non-devnet environment"
fi

# Step 2: Deploy AVS L1 contracts
log "2. Deploying AVS L1 contracts..."
PRIVATE_KEY_DEPLOYER="${PRIVATE_KEY_DEPLOYER}" make deploy-avs-l1-contracts RPC_URL="${L1_RPC_URL}" ENVIRONMENT="${ENVIRONMENT}" AVS_ADDRESS="${AVS_ADDRESS}" ALLOCATION_MANAGER_ADDRESS="${ALLOCATION_MANAGER_ADDRESS}" >&2

# Step 3: Deploy AVS L2 contracts
log "3. Deploying AVS L2 contracts..."
PRIVATE_KEY_DEPLOYER="${PRIVATE_KEY_DEPLOYER}" make deploy-avs-l2-contracts RPC_URL="${L2_RPC_URL}" ENVIRONMENT="${ENVIRONMENT}" >&2

# Step 4: Set up AVS Task Mailbox configuration
log "4. Setting up AVS Task Mailbox configuration..."
PRIVATE_KEY_AVS="${PRIVATE_KEY_AVS}" make setup-avs-task-mailbox-config RPC_URL="${L2_RPC_URL}" ENVIRONMENT="${ENVIRONMENT}" AGGREGATOR_OPERATOR_SET_ID=${AGGREGATOR_OPERATOR_SET_ID} EXECUTOR_OPERATOR_SET_ID=${EXECUTOR_OPERATOR_SET_ID} TASK_SLA=${TASK_SLA} >&2

log "Contract deployment completed successfully."

# Process deployment output files
OUTPUT_DIR="script/${ENVIRONMENT}/output"
# Initialize an empty array
result='[]'

# Default TaskMailbox address if not in devnet
DEFAULT_TASK_MAILBOX='{"address":"0x0000000000000000000000000000000000000000","name":"TaskMailbox"}'

# Process the core output file (only for devnet)
if [ "$ENVIRONMENT" == "devnet" ]; then
    CORE_FILE="${OUTPUT_DIR}/deploy_hourglass_core_output.json"
    if [ -f "$CORE_FILE" ]; then
        core_addresses=$(jq -c '[.addresses | to_entries[] | {"address": .value, "name": .key}]' "$CORE_FILE")
        result=$(echo "$result" | jq ". + $core_addresses")
    else
        log "Warning: Core output file $CORE_FILE not found"
        # Add default TaskMailbox
        result=$(echo "$result" | jq ". + [$DEFAULT_TASK_MAILBOX]")
    fi
else
    # Add default TaskMailbox for non-devnet environments
    result=$(echo "$result" | jq ". + [$DEFAULT_TASK_MAILBOX]")
fi

# Process the AVS L1 output file
L1_FILE="${OUTPUT_DIR}/deploy_avs_l1_output.json"
if [ -f "$L1_FILE" ]; then
    l1_addresses=$(jq -c '[.addresses | to_entries[] | {"address": .value, "name": .key}]' "$L1_FILE")
    result=$(echo "$result" | jq ". + $l1_addresses")
else
    log "Warning: AVS L1 output file $L1_FILE not found"
fi

# Process the AVS L2 output file
L2_FILE="${OUTPUT_DIR}/deploy_avs_l2_output.json"
if [ -f "$L2_FILE" ]; then
    l2_addresses=$(jq -c '[.addresses | to_entries[] | {"address": .value, "name": .key}]' "$L2_FILE")
    result=$(echo "$result" | jq ". + $l2_addresses")
else
    log "Warning: AVS L2 output file $L2_FILE not found"
fi

# Print the combined JSON result - this is the ONLY stdout output
echo "$result" | jq -c . 
